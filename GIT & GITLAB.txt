Basic Configuration Management & NSP CM process Overview


What are the common problems you encountered with your project repository and project work products?

Common problems encountered...
Updates of interfaces document was not communicated.
Wrong version of the interface of document is used to create the Basic Design.
Product shipped contained the wrong version of the source code.
	Difficulty in recreating a reported problems
	Reoccurrence of fixed bugs
	Inability to obtain the same version that our customers have 
	Lost/Misplaced source files
Share Code/ Share Data
	Some are not notified of bug fixes in code shared by several engineer.
Simultaneous Update
	Modification made in a file was overwritten


What is Configuration Management?
	Is the discipline of identifying the configuration of a system at distinct point in time for the purpose of systematically controlling changes to the configuration, and maintaing the integrity and traceability of the configuration throughout the system life cycle.

Purpose of Configuration Management

To establish and maintain the integrity of work products using: 

	configuration identification,
	configuration control, 
	configuration status accounting and 
	configuration audits


CM Principles

Integrity - The existence and correctness of the configuration items stored in the repository.

Traceability - To be able to trace or monitor changes made to the configuration items in the repository.
		To be alble to trace or monitor the relationship between the software and all other software products.


NSP CM process

NSP Process Architecture		NSP CM Process				Output

Project Initiation			CM Planning				CM Plan
	|				     |		
Project Planning			Establish Repository			Project Repository
	|				     |
--------------------------------------------------------------------------------WPR
	|				     |					
      BD/FD									Meeting Minutes								
	|
        DD									Audit Results	
	|			Perform CM Activities				
	CD									Project Baselines
	|																	
	Testing									Release
	|				     |					Backup	
------------------------------------------------------------------------------------------------------
	|				     |
Project Closure				Archive					Archived Project WP



CM Planning & Establish Repository

Purpose: To be able to plan the activities necessary for the execution of CM of the project group.

	Plan CM Activities
	Establish Project's repository
		Learn and Understand the CM plan

Members do not know how to perform the necessary CM Activities
Not all configuration items will be identified and controlled
Changes will not be handled properly
Too many documents to handle



CM Planning Standard Documents
	Configuration Management Plan Template
	Review Checklist
	Review Record Card Template
	Directory Structure Standard Guideline
	Document Registration Code, Version Number, and File Naming Guideline
	Checkin and Checkout Guideline


CM Activities: Configuration Identification

Purpose: To identify the project work products to be placed under configuration management
	
	Identify the project work products to be manage.
	Assign unique identifiers and location
	Record fucntional and physical characteristics of identified configuration items.
	Support traceability between the software and all other related software products.
	
		You can only manage and control items that you identified.
		The project may use their WBS to help them identify the possible output work products they may create and manage.


Document Control 
	Registration
	Naming Convention
	Versioning	

1. Department/Section & FY
2. Project Registration Series
3. Project Series 
	00 - Main Project
	01 - Subproject
4.Document Type
5.Document Series
6.Supporting document series
	001 for RRC series

					     Document Registration No.
					     /
			SWD10-05100-PLN008-001_Project Plan 1.xls
						    |		\
				         	Document Name	File Extension



		Final Copy/Major   Minor Revision 
	         Revision       \   |
				XX.YY.ZZ
					\
					Draft Version

Assigning unique identifiers help easier management and control of project work products.



Document Control

NSP Standard Directory  Structure

<Project Name>
:----Baseline Map.xls
:----Work Product Registry.xls
:------- 01 Project Management
:        :
:	 :---01 Initiation
:	 :
:	 :---02 PPMC
:	 :
:	 :---03 Closing
:
:------- O2 Engineering
:	 :
:	 :---01 Requirements
:	 :
:	 :---02 Design
:	 :
:	 :---03 Coding
:	 :
:	 :---04 Testing
:	 :
:	 :---05 User Documentation
:	 :
:	 :---06 Release
:	 :
:	 :---07 Libraries
:
:------- 03 Support
	 :
	 :---01 QA
	 :
	 :---02 Communications
 	 :
	 :---03 References
	 :
	 :---04 Tools

Tailoring
	Project Development lifecycle
	Deliverables required by client
	Addition of directories/Sub-directories




__________________________________________________________________________________________________________________________

Git is ...
Distributed
	Does not require a constant connection to a central server

Adaptive
	model can adapt to fit the workflow of almost any team


Fast and Reliable
	Git branches are sparse, allowing for change-only tracking.

Flexible
	git can be command line or GUI driven, allowing everyone to contribute




Terms for working with Git

Branch
	A branch is an independent line of development
Tag
	Mark a specific point in time on a branch
Checkout
	Get a specific branch to start making your changes
Commit 
	Adds changes you've made to the repository
Push	
	Send changes to a remote repository
Workspace
	Directory where you store the repository on your computer

Untracked files
	New files that Git has not been told to keep track of yet
Working area
	Files that have been modified but not committed

Staging Area
	Modified/Added files that are marked to go into the next commit

Local repository ("repo")
	Local copy of the entire upstream repository

Remote (upstream) repo
	Hosted repository on a shared  server (e.g Gitlab)



Document Control 

Revision History
	Records the changes made from one version to another


Sample 				Bad Practice			Good Practice

Updating design 		-Update section 5		Updated based on review #01:
document due to review 		-Retrieval of neType is not		- Corrected Recovery Time and Hold-off Time in
comments			indicated in page 8		Section 5 Scenario Value Pattern
									Added retrieval of neType in Section 7 Interface

Updating design document	Modified Window Image,		Removed function related to LO X-CON in sections: Window Image, Window Specification, Event and Interface base on MR#012 
due to requirements change	Window Specification,
				Event and Interface


Modifying source code		Modification in source code 	2010/12/15 by M. Bean - Modified to fix bug #01:
due to bug fix			is not accounted in revision	Removed function related to LO X-CON
				history				

			
				svn log sample:			svn log sample:
				Modified file due to bug fix	Modified file for bug fix #01
								Removed function related to LO X-CON

Revision History should be descriptive, brief and precise/specific



Configuration Control Activities

1. Repository Check in/Check out
2. Baselines
3. Change Control
4. Release
5. Backup


CM Activities: Configuration Identification

	Misplaced work products
	Changes are not accounted
	Correct version are not used as input document


Standard Document:
	Document Registration Code, Version Number, and file Naming Guidelines
	Directory Structure Standard Guidelines
	Work Product Registry Template




Doc vs. Repo Mapping Exercise

Test Cases & Test procedures documents
Team Member weekly Status Report
Development Source codes
Requirements List
Release Notes
Test Data
Contracts
Risk Management Plan
Monthly Project Status Report
Minutes of the meeting
Project Schedule
Detailed Design
Emails
Third Party Binary Files
Interface Document from Client
Integration Test Procedure
Release Procedure
SQA Evaluation and Audit Report
Project Development Plan
Build Scripts
Estimation worksheet
Unit Test Procedures
Lessons Learned Document
Project Proposal Document
MR form
SQA Plan
MR Log
Basic Design
MakeFile
Customer Survey Form
Review Management Sheet
Configuration Management Plan
HW & SW Development Environment Guide
Installation & User's Manual Document


CM Activities: Configuration Control

Purpose: To manage and control configuration items, ensuring its safety and security so that it will not be changed without proper authorization.

	Control Repository Access
	Manage Changes to all configuration items.
		External and Internal Modification Requests
	Perform Baselines
	Perform Release 
	Backup


Update WPR at least once a week to avoid bulk and tedious update.


Configuration Control Activities
1. Repository Check in/Check out
2. Baselines
3. Change Control
4. Release
5. Backup

1. Repository Check in/Check out

Purpose: To put work products into the repository using a version control application for easier retrieval and management.

Establish and follow the standart procedure in accessing the repository.
	Level of access to the repository
	Consistent access logging


Make sure that the files will be placed in the correct directory of the repository.
When checking-in source codes, make sure that the checked-in code will not contain or introduce errors when the whole system is compiled/build.
Be sure to check-in all work products before weekends or long vacation. If possible, check-in work products at the end of the day. This will keep the work product updated even if the responsible person will be absent on the next day.



2. Baselines
 
Purpose: To establish that the approved configuration items will serve as basis for further development and that it can be changed only through formal change control procedures.


Agree and Approve the configuration items (e.g design, code)
Use the approved configuration items as the basis of the next task.
Take a snapshot of the system at appropriate points in the project lifecycle.


Importance of Baselines

Baselines RL Basis for what product to develop.
Baseline Design basis for implementation of the product.
Baseline Source Codes basis for testing Activities

When creating a work product make sure that the referenced document used is the latest baseline.


3. Change Control

Purpose: To manage the changes of the baselines configuration items.

Manage configuration items that are affected by the change  (Requirement, Design, Review, etc..)
Access impact of changes to the baselines.
Maintain Traceability of the configuration items.
Ensure integrity of configuration items.


To maintain integrity of the repository:
	Always monitor changes in the repository.
	Always follow project's change control procedure.



Change Control Process

Issue Change Request <------------------------------------ Triggers
	|							Modification Request (Client/Developer)
Analyze, Propose, Review, And Approve					Changes in Requirements
MR Procedure, Bug Report, RRC						Changes in design
	|				\				Changes in behaviour
Implement Modification	  _____________| \					Bug Fix
	|		  |	       |  \	Monitor, Managed		Reviews
Confirm  Modification     |	       |  /	And Controlled by
	|		  |____________| /	CM-In-Charge
Release Changes                        |/





4. Release Activities

Purpose: To check readiness of the release items, prepare the deliverables and send to its intended recipient.

Check readiness of deliverables for release
Prepare and package deliverables.
Send package deliverables to intended recipient
PM gets confirmation from recipient



5. Backup - preservation of the content of the configuration management system.

Purpose: To be able to store the configuration items on a separate medium as a precautionary measure to prevent loss of data should the primary storage medium fail.

Preform regular backup as planned.
Check integrity of backup


CM Activities: Configuration Control

	Cannot Trace proper location of work products.
	Cannot determine which version is latest.
	Changes are not accounted.

Incorrect version of design is used as basis for coding

	Cannot trace why a change was made
	Changes are not properly disseminated
	Not all configuration item subject for change was updated.
	Updates could cause errors.

Package release is incorrect or lacking
We do not have copy of the released package.


Configuration Control Strandard Documents

Work Product Registry Template
Directory Structure standard
Checkin and Checkout Guideline
Modification Request (MR) Procedure
Modifiacation Request (MR) Log Template
Modification Request (MR) Template
Review Record Card Template
Problem Handling Sheet (PHS) Template
Test Result and Release Evaluation Checklist
Release Procedure
Release Notes Guideline
Release Notes Template

CM Activities: Configuration Audits (1/2)

Purpose: To Check integrity of the configuration management system of the group

Use the CM plan as the basis for all CM Audits.
Check the existence and correctness of the configuration items stored in the repository.
Check if changes made to the configuration items in the repository are traceable.
Resolve non-conformance(s) found.
Confirm Resolution.

	Perform CM Audit to Maintain the integrity of the repository
	Do Regular audits to avoid bulk and tedious CM Audit
	Always follow project's guidelines and procedure to limmit too much rework.
	Improve project's CM process from the weakness found



CM Activities: Configuration Audits
	Project cannot ensure the integrity of configuration management system
	Project member's practice might not be aligned with project's defined standards.
	Project may encounter repeating problems.

Standard Documents:
	Configuration Management Audits Guideline
	Configuration Management Audit Checklist
	Configuration Management Plan Template
	Work Product Registry Template





CM Activities: Status Accounting
	
Purpose: To check the status of all configuration items and track any changes made to them.

Check and update status of each configuration item in the WPR at least once a week.
Notify all stakeholders if necessary.




CM Activities: Status Accounting
	Project Cannot ensure the integrity of configuration management system.
	Project Member's practice might not be aligned with project's defined standards
	Project may encounter repeating problems

Standard Documents:
	Configuration Management Audit Guideline
	Configuration Management Audit Checklist


Archive

Purpose: To be able to take a final snapshot of the project which can be used as basis for future endeavors related to this project or for future project reference by other projects

Archive Project Work Products
	Note: Request to ITNA of Project Team uses the company wide repository
Give archive to SQA for storage.

	Difficulty in retrieving latest version of project work products.
	Project work products is lost.



SUMMARY



NSP Process Architecture		NSP CM Process				Output

Project Initiation			CM Planning				CM Plan
	|				     |		
Project Planning			Establish Repository			Project Repository
	|				     |
--------------------------------------------------------------------------------WPR
	|				     |					
      BD/FD									Meeting Minutes								
	|                          Perform CM Activities
        DD				Identification				Audit Results	
	|				Control			
	CD				Status Accounting			Project Baselines
	|				CM Audit													
	Testing									Release
	|				     |					Backup	
------------------------------------------------------------------------------------------------------
	|				     |
Project Closure				Archive					Archived Project WP





Which document contains the list of registered work products of the group that is under CM.
- Work Product Registry

It is the activity of putting/retrieving work products into/from the repository using a version control application.
- Repository Check in/Check out


It refers to a set of specifications or work products that has been formally reviewed and agreed on, which thereafter serves as the basis for further development, and which can be changed only through change control procedures.
- Baselines


It refers to the record of the changes made from one version to another.
- Revision History


_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Git vs.  Subversion

Distributed vs. Centralized Version Control Systems

Centralized
	RCS, CVS, Subversion
	All developers access a single central repository
	Working offline can be a challenge
	Need Access to repository to view history or to commit code.

Distributed
	Bitkeeper, Git, Mercurial
	Every developer has his/her own copy of the repository
	Developers can work offline - commit, branch, merge branches, view history
	Access to internet is only needed when synchronization with other team members is required.



Git vs. Subversion Features


Features			Subverion 			Git

Command Line			Monolithic			>150 Commands

File manager			Tight Integration		Command line front-end

IDE				All major IDEs 			All major IDEs

Continuous Integration		Jenkins, TeamCity,		Jenkins, TeamCity,		
				Bamboo...			Bamboo...	
				
Cloud				Private and Public Cloud	Private and Public Clous

Atomic commits			Snapshots No rollback		Snapshots with rollback

File renames			Manual renames 			Automatic and cross-repository
				Single repository		

Branches, tags, and		Supported as folders		First-class branches, tags, merge, rebase
Merging				Single-merge

Big files			Limited only by file-system	2 GB practical limit

Replication			Mirroring only			Master-slave
								Master-master
								Peer-to-peer



Git vs Subversion Security

		Channel Security	Authentication			Fine-grained security		Permission Model

Subversion	PKI, SSL, SSH		Basic Auth, X.509		Tag, path; branch		ACLs, RBAC
					Kerberos, SSH, LDAP/AD,
					SSO


Git		SSL, SSH		No auth, OS User, SSH		Only full repo R/W		OS file permmissions




Differences Between Git and SVN

Directory Structure
	Subversion	
		Trunk- represent the latest stable release
		Branches-activates features are developed in the subdirectories.

	
	Git
		Project are stored in single directory
		Master - contains the latest stable release
		branch - active features are developed in separate branches.
		Directory structure remains the same, but file content may change depending on the branch





Directory Structure


This is how an SVN directory structure look

Project ----> trunk -------> Current Sources
  |	\
  |	 \   
  |	  \ branches ------> Feature Branch
  |		     ------> Feature Branch 1
  |		     ------> Feature Branch 2
  |			O     O     O
  |		     ------> Experimental Brach	
  |
  |
   Tags ------> V1.0-beta1
	------> V1.0-rc1
	------> V1.0-RTM
		O   O    O
	------> V2.7.101
		




Comparison of Commands

Initial Checkout

Get a copy of the last revision from repository				Keep a copy of the entire repository
Can grab any particular path in the repository				Can grab only the entire respository

	
		SVN Repository							git central repository
		/								/
	       / Checkout						       /clone	
	      /								      /
	  dev A		dev B						  dev a 		dev B

$ svn checkout							$ git clone



Adding file

Used for adding new files				Used for adding new files and saving modification to existing files
							

	
		SVN Repository							git central repository
		/								
	       / add						 	   __    clone	
	      /								  |  |  
	  dev A		dev B						  dev a 		dev B
	path/file1.txt							path/file1.txt

$ svn add path/file1.txt					$ git add path/file1.txt


Status

Tracks unversioned, new, deleted, modified files				Track unversioned, new ,deleted, modified, and modified but not 'add'-ed
							

	
		SVN Repository							git central repository
		/								
	       / 						 	   __    
	      /								  |  |  
	  dev A		dev B						  dev a 		dev B
	path/file1.txt							path/file1.txt

$ svn status								$ git status






Commit

Send changes to remote repository					Only commit to local repository
Revision number is incrementing integer					Revision number is hash of the commit		

	
		SVN Repository							git central repository
		/								
	       / commit						 	   __  commit 	
	      /								  |  |  
	  dev A		dev B						  dev a 		dev B
	path/file1.txt							path/file1.txt

$ svn commit -m "Add file1"					$ git commit -m "Add file1"
$ svn log -q								$ git log -oneline
r3382 | eperez | 2017-05-12 14:04:34...								4ef8563 Add file1




Push

Send changes to remote repository				Send changes to the central repository
							

	
		SVN Repository							git central repository
		/								
	       /commit						 	   __  push	
	      /								  |  |  
	  dev A		dev B						  dev a 		dev B
	path/file1.txt							path/file1.txt

$ svn commit -m "Add file1"						$ git push





Compare

Compare file with central repository				Show the difference of local files
							

	
		SVN Repository							git central repository
		/								
	       / diff						 	   __ diff
	      /								  |  |  
	  dev A		dev B						  dev a 		dev B
	path/file1.txt							path/file1.txt

$ svn diff path/file1.txt						$ git diff path/file1.txt




Reverting

Revert changes in the working copy				Checkout a version of the last committed change
							

	
		SVN Repository							git central repository
		/								
	       / revert						 	   __  checkout	
	      /								  |  |  
	  dev A		dev B						  dev a 		dev B
	path/file1.txt							path/file1.txt

$ svn revert path/file1.txt					$ git checkout path/file1.txt






Updating

Bring changes from repository into working copy			Fetch from and integrate with another repository
							

	
		SVN Repository							git central repository
		/	\							/		\
	       / update	 \ commit					 	       / pull		 \ push
	      /		  \						      /   		  \
	  dev A		dev B						  dev a 		dev B
	path/file1.txt							path/file1.txt

$ svn update								$ git pull






Branching

Making changes immediately to remote repository				Local repository only
									Needs push to send to remote

	
		SVN Repository							git central repository
		/								
	       / copy						 	   __ checkout -b	
	      /								  |  |  
	  dev A		dev B						  dev a 		dev B
	path/file1.txt							path/file1.txt

$ svn copy .								$ git branch newbie
http://example.com/repo/branch/newbie					$ git checkout newbie
$svn switch -relocate
http://example.com/repo/branch/newbie



Example: Git workflow
# Clone and create "develop" branch
$ git clone ssh://user@host/path/to/repo.git
$ git checkout -b develop origin/develop		C2


# Create branch for new feature
$ git checkout -b some-feature develop
$git push -u origin some-feature			C3


#Feature is developed
$ git pull origin develop
$ git checkout develop
$ git merge --no-ff some-feature
$ git push origin develop

$ git branch -d some-feature


# Prepare a release, cleanup, test,...
$ git checkout -b release-0.1.0 develop			C14

# Finish the release
$ git checkout master 					C13
$ git merge --no-ff release-0.1.0
$ git push
$ git checkout develop
$ git merge --no-ff release-0.1.0
$ git push
$ git branch -d release-0.1.0

# If you pushed branch to origin
$ git push origin --delete release-0.1.0

$ git tag -a v0.1.0 master
$ git push-tags

#If customer found a bug, create a new branch
$ git checkout -b hotfix-0.1.1 master





Summary of Features comparison between svn and git


Feature			svn					git

Inital checkout		svn checkout				git clone
			http://example.com/repo			http://example.com/repo.git

Add file		svn aff path/file1.txt			git add path/file1.txt

Status			git status				git status

Commit			svn commit -m "Add file1"		git commit -m "Add file1"

Push			svn commit -m "Add file1"		git push

Compare			svn diff path/file1.txt			git diff path/file1.txt

Revert			svn revert path/file1.txt		git checkout path/file1.txt

Update			svn update				svn pull

Branch			svn copy:
			http://example.com/branch/newbie	git checkout -b newbie

Binary Storage		Support exclusive lock.			No support for exclusive lock and Copy-Modify-Merge is not applicable to binary files
							
								Not advisable for binary document (MS Word, excel, executable, libraries,...)

History			Keep track of all changes to a file/	Losses history if file is renamed. (Can be tracked in github/gitlab)
			folder					



_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Git Branching

You can seel all the commands available with "show commands" at the terminal

Git Commits
A commit in a git repository records a snapshot of all the files in your directory. It's like a giant copy and paste, but even better!

Git wants to keep commits as lightweight as possible though, so it doesn't just blindly copy the entire directory every time you commit. It can (when possible) compress a commit as a set of changes, or a "delta", from one version of the repository to the next.

Git also maintains a history of which commits were made when. That's why most commits have ancestor commits above them -- we designate this with arrows in our visualization. Maintaining history is great for everyone working on the project!

It's a lot to take in, but for now you can think of commits as snapshots of the project. Commits are very lightweight and switching between them is wicked fast!




Git Branches
Branches in Git are incredibly lightweight as well. They are simply pointers to a specific commit -- nothing more. This is why many Git enthusiasts chant the mantra:

"branch early, and branch often"

Because there is no storage / memory overhead with making many branches, it's easier to logically divide up your work than have big beefy branches.

When we start mixing branches and commits, we will see how these two features combine. For now though, just remember that a branch essentially says "I want to include the work of this commit and all parent commits."



git checkout <name>

This will put us on the new branch before committing our changes

ex. git checkout newImage; git commit



Here's a shortcut: if you want to create a new branch AND check it out at the same time, you can simply type 
git checkout -b [yourbranchname].





Branches and Merging
Great! We now know how to commit and branch. Now we need to learn some kind of way of combining the work from two different branches together. This will allow us to branch off, develop a new feature, and then combine it back in.

The first method to combine work that we will examine is "git merge". Merging in Git creates a special commit that has two unique parents. A commit with two parents essentially means "I want to include all the work from this parent over here and this one over here, and the set of all their parents."

It's easier with visuals, let's check it out in the next view




git checkout bugFix; git merge master

Since bugFix was an ancestor of master, git didn't have to do any work; it simply just moved bugFix to the same commit master was attached to.

Now all the commits are the same color, which means each branch contains all the work in the repository! Woohoo!



To complete this level, do the following steps:

Make a new branch called "bugFix"
	- git branch bugFix

Checkout the "bugFix" branch with "git checkout bugFix"
	- git checkout bugFix

Commit once
	- git commit

Go back to "master" with "git checkout"
	- git checkout master

Commit another time
	- git commit

Merge the branch "bugFix" into "master" with "git merge"
	-git merge bugFix
	-git merge master
Remember, you can always re-display this dialog with "objective"




Git Rebase
The second way of combining work between branches is rebasing. Rebasing essentially takes a set of commits, "copies" them, and plops them down somewhere else.

While this sounds confusing, the advantage of rebasing is that it can be used to make a nice linear sequence of commits. The commit log / history of the repository will be a lot cleaner if only rebasing is allowed.

Let's see it in action...


Here we have two branches yet again; note that the bugFix branch is currently selected (note the asterisk)
We would like to move our work from bugFix directly onto the work from master. That way it would look like these two features were developed sequentially, when in reality they were developed in parallel.
Let's do that with the git rebase command

git rebase master

Awesome! Now the work from our bugFix branch is right on top of master and we have a nice linear sequence of commits.
Note that the commit C3 still exists somewhere (it has a faded appearance in the tree), and C3' is the "copy" that we rebased onto master.
The only problem is that master hasn't been updated either, let's do that now...
Now we are checked out on the master branch. Let's go ahead and rebase onto bugFix...

git rebase bugFix

There! Since "master" was an ancestor of "bugFix", git simply moved the "master" branch reference forward in history.


To complete this level, do the following

Checkout a new branch named "bugFix"
- git checkout -b bugFix

Commit once
-git commit

Go back to master and commit again
-git checkout master
-git commit
Check out bugFix again and rebase onto master
-git checkout bugFix
-git rebase master
Good luck!





Moving around in Git
Before we get to some of the more advanced features of Git, it's important to understand different ways to move through the commit tree that represents your project.

Once you're comfortable moving around, your powers with other git commands will be amplified!



HEAD
First we have to talk about "HEAD". HEAD is the symbolic name for the currently checked out commit -- it's essentially what commit you're working on top of.
HEAD always points to the most recent commit which is reflected in the working tree. Most git commands which make changes to the working tree will start by changing HEAD.
Normally HEAD points to a branch name (like bugFix). When you commit, the status of bugFix is altered and this change is visible through HEAD.

Here we will reveal HEAD before and after a commit.

git checkout C1; git checkout master; git commit; git checkout C2

See! HEAD was hiding underneath our master branch all along.


Detaching HEAD
Detaching HEAD just means attaching it to a commit instead of a branch. This is what it looks like beforehand:
HEAD -> master -> C1

git checkout C1

And now it's
HEAD -> C1


To complete this level, let's detach HEAD from bugFix and attach it to the commit instead.
ex.
- git checkout C4
Specify this commit by its hash. The hash for each commit is displayed on the circle that represents the commit.




Relative Refs
Moving around in Git by specifying commit hashes can get a bit tedious. In the real world you won't have a nice commit tree visualization next to your terminal, so you'll have to use git log to see hashes.
Furthermore, hashes are usually a lot longer in the real Git world as well. For instance, the hash of the commit that introduced the previous level is fed2da64c0efc5293610bdd892f82a58e8cbc5d8. Doesn't exactly roll off the tongue...
The upside is that Git is smart about hashes. It only requires you to specify enough characters of the hash until it uniquely identifies the commit. So I can type fed2 instead of the long string above.
Like I said, specifying commits by their hash isn't the most convenient thing ever, which is why Git has relative refs. They are awesome!
With relative refs, you can start somewhere memorable (like the branch "bugFix" or "HEAD") and work from there.
Relative commits are powerful, but we will introduce two simple ones here:

Moving upwards one commit at a time with ^
Moving upwards a number of times with ~<num>
Let's look at the Caret (^) operator first. Each time you append that to a ref name, you are telling Git to find the parent of the specified commit.

So saying master^ is equivalent to "the first parent of master".
master^^ is the grandparent (second-generation ancestor) of master
Let's check out the commit above master here

git checkout master^

You can also reference "HEAD" as a relative ref. Let's use that a couple of times to move upwards in the commit tree

git checkout C3; git checkout HEAD^; git checkout HEAD^; git checkout HEAD^



To complete this level, check out the parent commit of bugFix. This will detach HEAD.

ex.
git checkout C4^
You can specify the hash if you want, but try using relative refs instead!


The "~" operator
Say you want to move a lot of levels up in the commit tree. It might be tedious to type ^ several times, so Git also has the tilde (~) operator.
The tilde operator (optionally) takes in a trailing number that specifies the number of parents you would like to ascend. Let's see it in action
Let's specify a number of commits back with ~.

git checkout HEAD~4



Branch forcing
You're an expert on relative refs now, so let's actually use them for something.
One of the most common ways I use relative refs is to move branches around. You can directly reassign a branch to a commit with the -f option. So something like:
git branch -f master HEAD~3

moves (by force) the master branch to three parents behind HEAD.


git branch -f master HEAD~3

There we go! Relative refs gave us a concise way to refer to C1 and branch forcing (-f) gave us a way to quickly move a branch to that location.
Now that you have seen relative refs and branch forcing in combination, let's use them to solve the next level.

To complete this level, move HEAD, master, and bugFix to their goal destinations shown.
-  git branch -f master C6
- git checkout Head~1
-  git branch -f bugfix HEAD~1



Reversing Changes in Git
There are many ways to reverse changes in Git. And just like committing, reversing changes in Git has both a low-level component (staging individual files or chunks) and a high-level component (how the changes are actually reversed). Our application will focus on the latter.

There are two primary ways to undo changes in Git -- one is using git reset and the other is using git revert. We will look at each of these in the next dialog



Git Reset
git reset reverts changes by moving a branch reference backwards in time to an older commit. In this sense you can think of it as "rewriting history;" git reset will move a branch backwards as if the commit had never been made in the first place.
Let's see what that looks like:

git reset HEAD~1
Nice! Git moved the master branch reference back to C1; now our local repository is in a state as if C2 had never happened.

Git Revert
While reseting works great for local branches on your own machine, its method of "rewriting history" doesn't work for remote branches that others are using.

In order to reverse changes and share those reversed changes with others, we need to use git revert. Let's see it in action
git revert HEAD

Weird, a new commit plopped down below the commit we wanted to reverse. That's because this new commit C2' introduces changes -- it just happens to introduce changes that exactly reverses the commit of C2.
With reverting, you can push out your changes to share with others.
To complete this level, reverse the most recent commit on both local and pushed. You will revert two commits total (one per branch).

-git checkout pushed
-git revert C2
-git checkout local
-git reset Head~1

Keep in mind that pushed is a remote branch and local is a local branch -- that should help you choose your methods.



Moving Work Around
So far we've covered the basics of git -- committing, branching, and moving around in the source tree. Just these concepts are enough to leverage 90% of the power of git repositories and cover the main needs of developers.
That remaining 10%, however, can be quite useful during complex workflows (or when you've gotten yourself into a bind). The next concept we're going to cover is "moving work around" -- in other words, it's a way for developers to say "I want this work here and that work there" in precise, eloquent, flexible ways.
This may seem like a lot, but it's a simple concept.


Git Cherry-pick
The first command in this series is called "git cherry-pick". It takes on the following form:

"git cherry-pick <Commit1> <Commit2> <...>"
It's a very straightforward way of saying that you would like to copy a series of commits below your current location (HEAD). I personally love cherry-pick because there is very little magic involved and it's easy to understand.
Let's see a demo!

Here's a repository where we have some work in branch side that we want to copy to master. This could be accomplished through a rebase (which we have already learned), but let's see how cherry-pick performs.
git cherry-pick C2 C4

That's it! We wanted commits C2 and C4 and git plopped them down right below us. Simple as that!



Git Interactive Rebase
Git cherry-pick is great when you know which commits you want (and you know their corresponding hashes) -- it's hard to beat the simplicity it provides.
But what about the situation where you don't know what commits you want? Thankfully git has you covered there as well! We can use interactive rebasing for this -- it's the best way to review a series of commits you're about to rebase.
Let's dive into the details...

All interactive rebase means is using the "rebase" command with the -i option.

If you include this option, git will open up a UI to show you which commits are about to be copied below the target of the rebase. It also shows their commit hashes and messages, which is great for getting a bearing on what's what.

For "real" git, the UI window means opening up a file in a text editor like vim. For our purposes, I've built a small dialog window that behaves the same way.
When the interactive rebase dialog opens, you have the ability to do 3 things:

You can reorder commits simply by changing their order in the UI (in our window this means dragging and dropping with the mouse).
You can choose to completely omit some commits. This is designated by "pick" -- toggling "pick" off means you want to drop the commit.
Lastly, you can squash commits. Unfortunately our levels don't support this for a few logistical reasons, so I'll skip over the details of this. Long story short, though -- it allows you to combine commits.
Great! Let's see an example.

When you hit the button, an interactive rebase window will appear. Reorder some commits around (or feel free to unpick some) and see the result!
git rebase -i HEAD~4

Boom! Git copied down commits in the exact same way you specified through the UI

git rebase -i overHere 
or git rebase -i C1,C3,C4,C5



Locally stacked commits
Here's a development situation that often happens: I'm trying to track down a bug but it is quite elusive. In order to aid in my detective work, I put in a few debug commands and a few print statements.
All of these debugging / print statements are in their own commits. Finally I track down the bug, fix it, and rejoice!
Only problem is that I now need to get my "bugFix" back into the "master" branch. If I simply fast-forwarded "master", then "master" would get all my debug statements which is undesirable. There has to be another way...

We need to tell git to copy only one of the commits over. This is just like the levels earlier on moving work around -- we can use the same commands:

git rebase -i
git cherry-pick
To achieve this goal.



This is a later level so we will leave it up to you to decide which command you want to use, but in order to complete the level, make sure master receives the commit that bugFix references.
- git rebase -i C1
- git branch -f master C4'




Juggling Commits
Here's another situation that happens quite commonly. You have some changes (newImage) and another set of changes (caption) that are related, so they are stacked on top of each other in your repository (aka one after another).
The tricky thing is that sometimes you need to make a small modification to an earlier commit. In this case, design wants us to change the dimensions of newImage slightly, even though that commit is way back in our history!!

We will overcome this difficulty by doing the following:

We will re-order the commits so the one we want to change is on top with "git rebase -i"
We will "commit --amend" to make the slight modification
Then we will re-order the commits back to how they were previously with "git rebase -i"
Finally, we will move master to this updated part of the tree to finish the level (via the method of your choosing)
There are many ways to accomplish this overall goal (I see you eye-ing cherry-pick), and we will see more of them later, but for now let's focus on this technique. Lastly, pay attention to the goal state here -- since we move the commits twice, they both get an apostrophe appended. One more apostrophe is added for the commit we amend, which gives us the final form of the tree

That being said, I can compare levels now based on structure and relative apostrophe differences. As long as your tree's master branch has the same structure and relative apostrophe differences, I'll give full credit
- git rebase -i HEAD~2
- git commit --amend
- git rebase -i HEAD~2 
- git rebase caption master












